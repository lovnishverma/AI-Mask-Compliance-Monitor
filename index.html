<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Mask Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>

    <style>
        :root {
            --col-green: #00ff84;
            --col-red: #ff4b4b;
            --col-bg: #0e0e0e;
            --col-surface: rgba(30, 30, 30, 0.9);
            --col-text: #ffffff;
            --radius: 12px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0.5rem;
            background-color: var(--col-bg);
            color: var(--col-text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h2 {
            font-weight: 700;
            font-size: clamp(1.5rem, 5vw, 2rem);
            margin: 0.5rem 0 1rem;
            text-align: center;
            letter-spacing: 0.5px;
        }

        #alert-banner {
            display: none;
            width: 100%;
            text-align: center;
            background-color: var(--col-red);
            color: white;
            font-weight: 700;
            font-size: clamp(0.9rem, 3vw, 1rem);
            padding: 8px 0;
            border-radius: var(--radius);
            margin-bottom: 0.75rem;
            animation: flash 1s infinite alternate;
        }

        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }

        #stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.75rem;
            width: 100%;
            max-width: 600px;
            margin-bottom: 1rem;
        }

        .stat-card {
            background-color: var(--col-surface);
            padding: 0.8rem;
            border-radius: var(--radius);
            text-align: center;
            backdrop-filter: blur(8px);
            transition: transform 0.2s;
        }

        .stat-card:active {
            transform: scale(0.95);
        }

        .stat-card h3 {
            margin: 0 0 0.4rem;
            font-size: clamp(0.7rem, 2.5vw, 0.85rem);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            opacity: 0.8;
        }

        .stat-card-number {
            font-size: clamp(1.4rem, 4vw, 1.8rem);
            font-weight: 700;
        }

        #mask-count { color: var(--col-green); }
        #nomask-count { color: var(--col-red); }

        #container {
            position: relative;
            width: 100%;
            max-width: 640px;
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
            aspect-ratio: 4 / 3;
            background: #000;
            margin-bottom: 0.75rem;
        }

        #video, #canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0; left: 0;
        }

        canvas {
            z-index: 1;
        }

        .label {
            position: absolute;
            padding: 4px 7px;
            border-radius: 6px;
            font-weight: bold;
            font-size: clamp(11px, 2.8vw, 14px);
            color: #fff;
            background: rgba(0,0,0,0.6);
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
            z-index: 2;
            pointer-events: none;
        }

        #controls {
            display: flex;
            gap: 0.75rem;
            width: 100%;
            max-width: 600px;
            justify-content: center;
            margin-bottom: 0.5rem;
        }

        button {
            background-color: var(--col-surface);
            color: var(--col-text);
            border: none;
            padding: 0.75rem 1.2rem;
            border-radius: var(--radius);
            font-size: clamp(0.85rem, 3vw, 1rem);
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            backdrop-filter: blur(8px);
            transition: all 0.2s;
        }

        button:active {
            transform: scale(0.95);
            background-color: rgba(50, 50, 50, 0.9);
        }

        #performance {
            margin-top: 0.5rem;
            font-size: clamp(0.75rem, 2.5vw, 0.9rem);
            opacity: 0.7;
            text-align: center;
        }
    </style>
</head>

<body>
    <h2>AI Mask Monitor</h2>
    <div id="alert-banner">MASK VIOLATION!</div>

    <div id="stats-container">
        <div class="stat-card">
            <h3>With Mask</h3>
            <div id="mask-count" class="stat-card-number">0</div>
        </div>
        <div class="stat-card">
            <h3>No Mask</h3>
            <div id="nomask-count" class="stat-card-number">0</div>
        </div>
        <div class="stat-card">
            <h3>Total</h3>
            <div id="total-count" class="stat-card-number">0</div>
        </div>
        <div class="stat-card">
            <h3>FPS</h3>
            <div id="fps" class="stat-card-number">0</div>
        </div>
    </div>

    <div id="container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
    </div>

    <div id="controls">
        <button id="flip-camera">
            <span id="camera-icon">Back Camera</span>
        </button>
    </div>

    <div id="performance">Initializing camera...</div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const maskEl = document.getElementById('mask-count');
        const noMaskEl = document.getElementById('nomask-count');
        const totalEl = document.getElementById('total-count');
        const fpsEl = document.getElementById('fps');
        const alertBanner = document.getElementById('alert-banner');
        const container = document.getElementById('container');
        const flipBtn = document.getElementById('flip-camera');
        const cameraIcon = document.getElementById('camera-icon');

        let faceModel, maskModel;
        let audioContext;
        let currentStream = null;
        let isFrontCamera = false; // Start with back camera
        let lastAlertTime = 0;
        const alertThrottle = 2000;
        let lastFrameTime = performance.now();
        let totalMasks = 0, totalNoMasks = 0, totalDetections = 0;

        // Dynamic canvas resize
        function resizeCanvas() {
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        window.addEventListener('resize', resizeCanvas);

        // Stop current stream
        function stopStream() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
        }

        // Toggle camera
        async function flipCamera() {
            isFrontCamera = !isFrontCamera;
            cameraIcon.textContent = isFrontCamera ? 'Front Camera' : 'Back Camera';
            await stopStream();
            await startCamera();
        }

        flipBtn.addEventListener('click', flipCamera);

        function playAlert() {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(1000, audioContext.currentTime);
            gain.gain.setValueAtTime(0.15, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            osc.connect(gain).connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.2);
        }

        async function startCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: isFrontCamera ? 'user' : 'environment',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                video.srcObject = stream;

                await new Promise(r => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resizeCanvas();
                        r();
                    };
                });

            } catch (err) {
                console.error("Camera error:", err);
                document.getElementById('performance').textContent = 
                    err.name === 'OverconstrainedError' 
                        ? 'Camera not available. Try the other one.' 
                        : 'Camera access denied.';
            }
        }

        async function init() {
            try {
                // Unlock audio on iOS
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    const unlock = () => {
                        audioContext.resume().then(() => {
                            document.removeEventListener('touchstart', unlock);
                            document.removeEventListener('click', unlock);
                        });
                    };
                    document.addEventListener('touchstart', unlock);
                    document.addEventListener('click', unlock);
                }

                [faceModel, maskModel] = await Promise.all([
                    blazeface.load(),
                    tf.loadGraphModel('model_web/model.json')
                ]);

                await startCamera();
                document.getElementById('performance').textContent = 'Running...';
                detectFaces();
            } catch (err) {
                document.getElementById('performance').textContent = 'Failed to load models or access camera.';
                console.error(err);
            }
        }

        async function detectFaces() {
            if (!video.videoWidth || video.readyState < 2) {
                requestAnimationFrame(detectFaces);
                return;
            }

            const startTime = performance.now();
            resizeCanvas();
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            const scaleX = canvas.width / video.videoWidth;
            const scaleY = canvas.height / video.videoHeight;

            const faces = await faceModel.estimateFaces(video, false);
            document.querySelectorAll('.label').forEach(el => el.remove());

            let maskCount = 0, noMaskCount = 0;

            for (const face of faces) {
                const [x1, y1] = face.topLeft;
                const [x2, y2] = face.bottomRight;

                const scaled = {
                    x1: x1 * scaleX, y1: y1 * scaleY,
                    x2: x2 * scaleX, y2: y2 * scaleY
                };

                const faceTensor = tf.tidy(() => {
                    const img = tf.browser.fromPixels(video);
                    const normBox = [
                        y1 / video.videoHeight,
                        x1 / video.videoWidth,
                        y2 / video.videoHeight,
                        x2 / video.videoWidth
                    ];
                    return tf.image.cropAndResize(
                        img.expandDims(0).toFloat(),
                        [normBox], [0], [128, 128]
                    ).div(255.0);
                });

                const [withMask, noMask] = await maskModel.predict(faceTensor).data();
                const isMask = withMask > noMask;
                const confidence = Math.max(withMask, noMask);
                const label = isMask ? 'WITH MASK' : 'NO MASK';
                const color = isMask ? 'var(--col-green)' : 'var(--col-red)';

                ctx.strokeStyle = color;
                ctx.lineWidth = Math.max(2, canvas.width / 200);
                ctx.strokeRect(scaled.x1, scaled.y1, scaled.x2 - scaled.x1, scaled.y2 - scaled.y1);

                const labelEl = document.createElement('div');
                labelEl.className = 'label';
                labelEl.style.left = `${scaled.x1}px`;
                labelEl.style.top = `${(scaled.y1 > 20 ? scaled.y1 - 20 : scaled.y1 + 5)}px`;
                labelEl.style.background = color;
                labelEl.textContent = `${label} ${(confidence * 100).toFixed(0)}%`;
                container.appendChild(labelEl);

                if (isMask) maskCount++;
                else noMaskCount++;

                tf.dispose(faceTensor);
            }

            maskEl.textContent = maskCount;
            noMaskEl.textContent = noMaskCount;
            totalMasks += maskCount;
            totalNoMasks += noMaskCount;
            totalDetections += faces.length;
            totalEl.textContent = totalDetections;

            if (noMaskCount > 0) {
                const now = Date.now();
                if (now - lastAlertTime > alertThrottle) {
                    playAlert();
                    alertBanner.style.display = "block";
                    lastAlertTime = now;
                    setTimeout(() => alertBanner.style.display = "none", 1500);
                }
            }

            const fps = (1000 / (performance.now() - lastFrameTime)).toFixed(1);
            lastFrameTime = performance.now();
            fpsEl.textContent = fps;

            requestAnimationFrame(detectFaces);
        }

        // Start on load
        window.onload = () => {
            setTimeout(init, 300);
        };
    </script>
</body>

</html>
